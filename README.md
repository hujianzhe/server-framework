# server framework
跨平台底层库 https://github.com/hujianzhe/util, 下载后置于BootServer目录下  

简介：
本代码只实现节点启动自举与集群节点之间的消息联动基础接口，不包含任何业务代码，纯C实现，功能方面保持克制  
因为具体业务千差万别，要求各异，所以服务发现模块交由具体业务侧处理  
模块内部由多个线程处理io，另有一个工作线程（默认开一个）处理内部消息和收到的网络消息并派遣到你的业务代码逻辑中  
工作线程使用有栈协程进行调度处理（未使用无栈协程的原因见下文）  
跨平台，不依赖任何第三方框架  
网络通信支持TCP和可靠UDP  

TODO:  
1、一个好的说明文档，实在没时间写  
2、对脚本语言编写业务逻辑提供支持  

模块介绍:  
1、BootServer：服务节点启动的必备初始化和操作  
2、ServiceTemplate：服务节点代码模板，用来写你的业务逻辑  
3、SoTestClient,SoTestServer：测试节点，用于测试功能  

编译:  
windows直接VS编译  
linux下使用make debug 或 make release  

启动:  
编辑好服务节点启动需要的配置文件(具体格式参看附带的配置文件模板)，给每个节点一个配置文件和唯一id，日志标识名，IP和端口号  
windows直接VS打开，工程配置好启动参数  <配置文件>  
linux/mac编译后，sh run.sh <服务进程> <配置文件>  

一些设计原因与见解：  
Q:为何不使用无栈协程而采用有栈协程？  
A:纯C实现无栈协程是容易的（详细代码可以看util库中用纯C实现的无栈协程调度器），但资源回收与持久化（尤其是栈上变量在协程重入后的情形）是极度困难的  
  想顺手的使用无栈协程还是得靠编译器支持，这点C++20已经做到，util库中也有完整的C++20无栈协程调度器实现  
Q:为何不直接用C++做框架？  
A:1.写这套代码时候，C++20还没出现，那时候相对最成熟的协程方案就是有栈协程，这个用C通过调用对应平台系统API就可以做到  
  2.此类框架要实现的功能已经固化，资源的生命周期都是流程固化的，用纯C实现恰好足够（之前有过一个C++实现的版本，感觉反而代码变得复杂了）  
  3.要导出动态库被其他模块调用，还是需要C封一层接口  
Q:业务层能继续使用纯C开发么？  
A:非常不建议，因为异步流程的编写，以及高级语言编写的模块中抛出了异常，这些都让资源销毁的时机变得无法确定，这时仍用纯C去人为手动控制资源是极度困难的  
  应该使用更高级的语言去处理这些事情，比如可以用C++开发上层业务代码，它的RAII机制可以确保对应资源的释放（使用std::shared_ptr管理内存对象，使用类的析构函数去释放协程锁对象）  
Q:为何目前不允许协程迁移到不同线程中执行？  
A:迁移协程可以很容易做到，但不提供的原因是  
  1.因为协程之间执行的任务是不确定的，可能是会造成io与计算混在同一个调度线程中  
  2.因为迁移后同一个协程过程就可能会运行在不同线程上了，这时候必须保证你的代码不依赖线程本地变量，但你无法确保第三方库没有使用线程本地变量  
